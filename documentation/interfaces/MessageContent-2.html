<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>dabubble documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">dabubble documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  MessageContent</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/private-messages/private-messages.component.ts</code>
        </p>


            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Defines the structure of a message&#39;s content, which may include text,
an optional image, and an array of emojis with usage counts.</p>

            </p>


        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#emojis" 
>
                                            emojis
                                        </a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#image" 
>
                                            image
                                        </a>
                                </li>
                                <li>
                                            <span class="modifier">Optional</span>
                                        <a href="#text" 
>
                                            text
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="emojis"></a>
                                        <span class="name "><b>emojis</b>
                                            <a href="#emojis">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>emojis:     <code>Array&lt;literal type&gt;</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>Array&lt;literal type&gt;</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="image"></a>
                                        <span class="name "><b>image</b>
                                            <a href="#image">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>image:     <code>string | ArrayBuffer | null</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>string | ArrayBuffer | null</code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="text"></a>
                                        <span class="name "><b>text</b>
                                            <a href="#text">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>text:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>

                                    <tr>
                                        <td class="col-md-4">
                                            <i>Optional</i>
                                        </td>
                                    </tr>




                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {
  Component,
  OnInit,
  CUSTOM_ELEMENTS_SCHEMA,
  ViewChild,
  ElementRef,
  Input,
  EventEmitter,
  Output,
  OnChanges,
  SimpleChanges,
  HostListener,
} from &#x27;@angular/core&#x27;;
import { CommonModule, formatDate } from &#x27;@angular/common&#x27;;
import { FormsModule } from &#x27;@angular/forms&#x27;;
import { PickerModule } from &#x27;@ctrl/ngx-emoji-mart&#x27;;
import { ChannelService } from &#x27;../channel.service&#x27;;
import { UserService } from &#x27;../user.service&#x27;;
import { MatDialog } from &#x27;@angular/material/dialog&#x27;;
import { MessageService } from &#x27;../message.service&#x27;;
import { ActivatedRoute } from &#x27;@angular/router&#x27;;
import firebase from &#x27;firebase/compat/app&#x27;;
import &#x27;firebase/compat/firestore&#x27;;
import { OverlayModule } from &#x27;@angular/cdk/overlay&#x27;;
import { Message } from &#x27;../message.models&#x27;;

/**
 * Defines the structure of a message&#x27;s content, which may include text,
 * an optional image, and an array of emojis with usage counts.
 */
export interface MessageContent {
  text?: string;
  image?: string | ArrayBuffer | null;
  emojis: Array&lt;{ emoji: string; count: number }&gt;;
}

@Component({
  selector: &#x27;app-private-messages&#x27;,
  standalone: true,
  imports: [CommonModule, FormsModule, PickerModule, OverlayModule],
  templateUrl: &#x27;./private-messages.component.html&#x27;,
  styleUrls: [&#x27;./private-messages.component.scss&#x27;],
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
})
export class PrivateMessagesComponent implements OnInit, OnChanges {
  @ViewChild(&#x27;messageList&#x27;) messageList!: ElementRef;

  @Input() recipientName: string &#x3D; &#x27;&#x27;;
  @Input() recipientId: string &#x3D; &#x27;&#x27;;
  @Output() memberSelected &#x3D; new EventEmitter&lt;any&gt;();
  @Input() showSearchField: boolean &#x3D; false;
  @Output() openThread &#x3D; new EventEmitter&lt;any&gt;();
  @Input() threadData: any &#x3D; null;
  @ViewChild(&#x27;textArea&#x27;) textAreaRef!: ElementRef&lt;HTMLTextAreaElement&gt;;

  parentMessage: any &#x3D; null;
  imageUrl: string | ArrayBuffer | null &#x3D; null;
  privateMessage: string &#x3D; &#x27;&#x27;;
  currentUser: any;
  conversationId: string | undefined;
  recipientStatus: string &#x3D; &#x27;&#x27;;
  recipientAvatarUrl: string &#x3D; &#x27;&#x27;;
  isEmojiPickerVisible: boolean &#x3D; false;
  isImageModalOpen &#x3D; false;
  currentDate: Date &#x3D; new Date();
  yesterdayDate: Date &#x3D; this.getYesterdayDate();
  isTextareaExpanded: boolean &#x3D; false;
  message: string &#x3D; &#x27;&#x27;;
  lastUsedEmojisReceived: string[] &#x3D; [];
  lastUsedEmojisSent: string[] &#x3D; [];
  showEditOptions: boolean &#x3D; false;
  currentMessageId: string | null &#x3D; null;
  originalMessage: any &#x3D; null;
  tooltipVisible &#x3D; false;
  tooltipPosition &#x3D; { x: 0, y: 0 };
  tooltipEmoji &#x3D; &#x27;&#x27;;
  tooltipSenderName &#x3D; &#x27;&#x27;;
  selectedThread: any &#x3D; null;
  latestTimestamp: Date | null &#x3D; null;
  selectedMember: any &#x3D; null;
  allUsers: any[] &#x3D; [];
  showUserDropdown: boolean &#x3D; false;
  privateMessages: Message[] &#x3D; [];
  showLargeImage &#x3D; false;
  largeImageUrl: string | null &#x3D; null;
  private hasScrolledOnChange: boolean &#x3D; false;
  private isChatChanging: boolean &#x3D; false;
  isDesktop &#x3D; false;

  allChannels: any[] &#x3D; [];
  dropdownState: &#x27;hidden&#x27; | &#x27;user&#x27; | &#x27;channel&#x27; &#x3D; &#x27;hidden&#x27;;
  private cycleStep &#x3D; 1;
  lastOpenedChar &#x3D; &#x27;&#x27;;

  userMap: {
    [uid: string]: { name: string; avatarUrl: string } | undefined;
  } &#x3D; {};

  private replyCache: Map&lt;string, any[]&gt; &#x3D; new Map();
  private unsubscribeFromThreadMessages: (() &#x3D;&gt; void) | null &#x3D; null;
  private unsubscribeLiveReplyCounts: (() &#x3D;&gt; void) | null &#x3D; null;
  private unsubscribeFromThreadDetails: (() &#x3D;&gt; void) | null &#x3D; null;
  private unsubscribeEmojiListener?: () &#x3D;&gt; void;
  private unsubscribeFromPrivateMessages: (() &#x3D;&gt; void) | null &#x3D; null;
  private unsubscribeRecipient?: () &#x3D;&gt; void;
  private unsubscribeChannels: (() &#x3D;&gt; void) | null &#x3D; null;
  private unsubscribeUsers: (() &#x3D;&gt; void) | null &#x3D; null;

  /**
   * Constructor injecting services for route info, user data, channel logic, dialogs, and messages.
   */
  constructor(
    private route: ActivatedRoute,
    private userService: UserService,
    private channelService: ChannelService,
    private dialog: MatDialog,
    private messageService: MessageService
  ) {}

  /**
   * Lifecycle hook: loads the current user, sets up the conversation if recipient is known,
   * and starts real-time updates (messages, emojis, reply counts, date refresh).
   */
  async ngOnInit(): Promise&lt;void&gt; {
    await this.loadCurrentUser();
    this.loadRecipientData();
    this.checkDesktopWidth();
    this.setupRecipientListener();
    this.initPrivateConversation();
    this.initChannelAndUserSubscriptions();

    setTimeout(() &#x3D;&gt; this.focusTextArea(), 0);
  }

  /**
   * Initializes the private conversation if currentUser and recipientId are defined,
   * then sets up listeners for messages, emojis, reply counts, and date updates.
   */
  private initPrivateConversation(): void {
    if (!this.currentUser?.id || !this.recipientId) return;
    this.conversationId &#x3D; this.messageService.generateConversationId(
      this.currentUser.id,
      this.recipientId
    );
    this.setupMessageListener();
    this.listenForEmojiUpdates();
    this.loadLastUsedEmojis();
    this.startLiveReplyCountUpdates();
    this.startDateUpdater();
  }

  /**
   * Subscribes to channel and user updates, storing the unsubscribe functions.
   */
  private initChannelAndUserSubscriptions(): void {
    this.unsubscribeChannels &#x3D; this.channelService.getAllChannels((ch) &#x3D;&gt; {
      this.allChannels &#x3D; ch;
    });

    this.unsubscribeUsers &#x3D; this.userService.getAllUsersLive((users) &#x3D;&gt; {
      this.allUsers &#x3D; users;
      users.forEach((u) &#x3D;&gt; {
        this.userMap[u.id] &#x3D; {
          name: u.name || &#x27;Unbekannt&#x27;,
          avatarUrl: u.avatarUrl || &#x27;assets/img/avatar.png&#x27;,
        };
      });
    });
  }

  /**
   * HostListener to detect window resize events and update desktop mode.
   */
  @HostListener(&#x27;window:resize&#x27;)
  onResize() {
    this.checkDesktopWidth();
  }

  /**
   * Closes the dropdown when a click occurs outside its container.
   * @param {MouseEvent} event - The global document click event.
   */
  @HostListener(&#x27;document:click&#x27;, [&#x27;$event&#x27;])
  onDocumentClick(event: MouseEvent): void {
    if (this.dropdownState !&#x3D;&#x3D; &#x27;hidden&#x27;) {
      this.dropdownState &#x3D; &#x27;hidden&#x27;;
      this.cycleStep &#x3D; 1;
    }
    if (this.isEmojiPickerVisible) {
      this.isEmojiPickerVisible &#x3D; false;
    }
  }

  /**
   * Prevents the dropdown from closing if clicked inside its container.
   * @param {MouseEvent} event - The local container click event.
   */
  onSelfClick(event: MouseEvent): void {
    event.stopPropagation();
  }

  /**
   * Checks if screen width &gt;&#x3D; 1278 to mark as desktop mode.
   */
  checkDesktopWidth() {
    this.isDesktop &#x3D; window.innerWidth &gt;&#x3D; 1278;
  }

  /**
   * Sets an interval to update message dates periodically (e.g. &quot;Heute&quot; &#x3D;&gt; &quot;Gestern&quot;).
   */
  private startDateUpdater(): void {
    setInterval(() &#x3D;&gt; {
      this.updateMessageDates();
    }, 60000);
  }

  /**
   * Recomputes formattedDate for each message to reflect daily changes.
   */
  private updateMessageDates(): void {
    const updatedMessages &#x3D; this.privateMessages.map((msg) &#x3D;&gt; ({
      ...msg,
      formattedDate: this.getFormattedDate(msg.timestamp),
    }));
    this.privateMessages &#x3D; [...updatedMessages];
  }

  private setupRecipientListener() {
    // Hier rufen wir nun die neue Service-Methode auf
    this.unsubscribeRecipient &#x3D; this.messageService.onRecipientStatusChanged(
      this.recipientId,
      (data) &#x3D;&gt; {
        // data: { isOnline: boolean; avatarUrl: string; name: string }
        this.recipientStatus &#x3D; data.isOnline ? &#x27;Aktiv&#x27; : &#x27;Abwesend&#x27;;
        this.recipientAvatarUrl &#x3D; data.avatarUrl;
        this.recipientName &#x3D; data.name;
      }
    );
  }

  /**
   * Sets up a live listener for new private messages, auto-scrolling if user near bottom or if new messages arrive.
   */
  private setupMessageListener(): void {
    if (this.unsubscribeFromThreadMessages) {
      this.unsubscribeFromThreadMessages();
    }

    this.hasScrolledOnChange &#x3D; false;
    let oldCount &#x3D; this.privateMessages.length;

    this.unsubscribeFromThreadMessages &#x3D; this.messageService.listenMessages(
      &#x27;private&#x27;,
      this.conversationId!,
      (rawMessages) &#x3D;&gt; {
        this.processIncomingMessages(rawMessages);

        const wasNearBottom &#x3D; this.isNearBottom(150);
        const newCount &#x3D; rawMessages.length;
        if (newCount &gt; oldCount || wasNearBottom) {
          this.scrollToBottom();
        }
        oldCount &#x3D; newCount;
      }
    );
  }

  /**
   * Checks if the user is near the bottom of the message list within a threshold.
   */
  private isNearBottom(threshold &#x3D; 100): boolean {
    const el &#x3D; this.messageList?.nativeElement;
    if (!el) return false;
    const distanceToBottom &#x3D; el.scrollHeight - el.scrollTop - el.clientHeight;
    return distanceToBottom &lt;&#x3D; threshold;
  }

  /**
   * Scrolls to bottom if user is near the bottom or if switching chats immediately.
   */
  private scrollToBottom(): void {
    if (this.isChatChanging) {
      const lastMessage &#x3D; this.messageList?.nativeElement.lastElementChild;
      if (lastMessage) {
        setTimeout(() &#x3D;&gt; {
          lastMessage.scrollIntoView({ behavior: &#x27;smooth&#x27;, block: &#x27;end&#x27; });
        }, 100);
      }
      return;
    }

    if (this.isNearBottom()) {
      setTimeout(() &#x3D;&gt; {
        if (this.messageList) {
          this.messageList.nativeElement.scrollTop &#x3D;
            this.messageList.nativeElement.scrollHeight;
        }
      }, 100);
    }
  }

  /**
   * Called whenever @Input properties change. Dispatches to helper methods for
   * recipient changes or thread data updates.
   */
  ngOnChanges(changes: SimpleChanges): void {
    this.handleRecipientChanges(changes);
    this.handleThreadDataChanges(changes);
  }

  /**
   * Handles logic when recipientId changes: clears old listeners, reloads data,
   * scrolls to bottom, and restarts live reply counts.
   */
  private handleRecipientChanges(ch: SimpleChanges): void {
    const rc &#x3D; ch[&#x27;recipientId&#x27;];
    if (!rc || rc.isFirstChange()) return;

    this.hasScrolledOnChange &#x3D; true;
    this.isChatChanging &#x3D; true;
    this.cleanupListeners();
    this.loadRecipientData();
    this.loadPrivateMessages();
    if (this.unsubscribeRecipient) this.unsubscribeRecipient();
    this.setupRecipientListener();
    setTimeout(() &#x3D;&gt; {
      this.scrollToBottom();
      this.isChatChanging &#x3D; false;
      this.focusTextArea();
    }, 200);
    this.startLiveReplyCountUpdates();
  }

  /**
   * Focuses the textarea so the user can immediately start typing.
   */
  private focusTextArea(): void {
    if (this.textAreaRef) {
      this.textAreaRef.nativeElement.focus();
    }
  }

  /**
   * Handles logic when threadData changes, updating timestamp if present.
   */
  private handleThreadDataChanges(ch: SimpleChanges): void {
    const td &#x3D; ch[&#x27;threadData&#x27;]?.currentValue;
    if (!td?.timestamp) return;

    this.getFormattedDate(td.timestamp);
    formatDate(td.timestamp, &#x27;HH:mm&#x27;, &#x27;de&#x27;);
  }

  /**
   * Loads private messages for the current conversation from Firestore
   * and sets up a live listener for updates.
   */
  async loadPrivateMessages(): Promise&lt;void&gt; {
    if (!this.currentUser?.id || !this.recipientId) return;
    const cId &#x3D; this.messageService.generateConversationId(
      this.currentUser.id,
      this.recipientId
    );
    if (this.unsubscribeFromPrivateMessages)
      this.unsubscribeFromPrivateMessages();
    this.unsubscribeFromPrivateMessages &#x3D;
      this.messageService.getPrivateMessagesLive(cId, (msgs) &#x3D;&gt;
        this.handlePrivateMessagesLive(msgs)
      );
  }

  /**
   * Transforms incoming messages by converting timestamps and
   * updating local references, then scrolls down after a short delay.
   */
  private handlePrivateMessagesLive(messages: any[]): void {
    this.privateMessages &#x3D; messages.map((msg) &#x3D;&gt; {
      const ts &#x3D; this.safeConvertTimestamp(msg.timestamp);
      const lr &#x3D; msg.lastResponseTime
        ? this.safeConvertTimestamp(msg.lastResponseTime)
        : ts;
      return {
        ...msg,
        timestamp: ts,
        lastResponseTime: lr,
        formattedDate: this.getFormattedDate(ts),
        content: { ...msg.content, emojis: msg.content?.emojis || [] },
      };
    });
    setTimeout(() &#x3D;&gt; this.scrollToBottom(), 200);
  }

  /**
   * Removes all active listeners for messages, replies, and emojis, typically before switching chat or on destroy.
   */
  private cleanupListeners(): void {
    if (this.unsubscribeLiveReplyCounts) {
      this.unsubscribeLiveReplyCounts();
      this.unsubscribeLiveReplyCounts &#x3D; null;
    }
    if (this.unsubscribeFromThreadMessages) {
      this.unsubscribeFromThreadMessages();
      this.unsubscribeFromThreadMessages &#x3D; null;
    }
  }

  /**
   * Called when component destroyed, unsubscribes from all live queries, clears caches.
   */
  ngOnDestroy(): void {
    if (this.unsubscribeFromThreadMessages) {
      this.unsubscribeFromThreadMessages();
      this.unsubscribeFromThreadMessages &#x3D; null;
    }
    if (this.unsubscribeFromThreadDetails) {
      this.unsubscribeFromThreadDetails();
      this.unsubscribeFromThreadDetails &#x3D; null;
    }
    if (this.unsubscribeEmojiListener) {
      this.unsubscribeEmojiListener();
    }
    if (this.unsubscribeLiveReplyCounts) {
      this.unsubscribeLiveReplyCounts();
      this.unsubscribeLiveReplyCounts &#x3D; null;
    }
    this.replyCache.clear();
  }

  ngOnHelpDestroy(): void {
    if (this.unsubscribeFromPrivateMessages) {
      this.unsubscribeFromPrivateMessages();
    }
    if (this.unsubscribeRecipient) {
      this.unsubscribeRecipient();
    }
    if (this.unsubscribeChannels) {
      this.unsubscribeChannels();
    }
    if (this.unsubscribeUsers) {
      this.unsubscribeUsers();
    }
  }

  /**
   * Processes raw messages from Firestore by converting timestamps,
   * setting daily separators, and then updates live reply counts.
   *
   * @param {Message[]} rawMessages - The array of incoming Firestore messages.
   */
  private processIncomingMessages(rawMessages: Message[]): void {
    rawMessages.forEach((msg) &#x3D;&gt; {
      if (msg.senderId &amp;&amp; !this.userMap[msg.senderId]) {
        this.loadUserIntoMap(msg.senderId);
      }
    });

    let prevDate: Date | null &#x3D; null;

    const updated &#x3D; rawMessages.map((msg, i) &#x3D;&gt; {
      const ts &#x3D; this.safeConvertTimestamp(msg.timestamp);
      const showSep &#x3D; i &#x3D;&#x3D;&#x3D; 0 || !this.isSameDay(prevDate, ts);
      prevDate &#x3D; ts;
      return this.transformIncomingMessage(msg, ts, showSep);
    });

    this.privateMessages &#x3D; [...updated];
    this.updateLiveReplyCounts(updated);
  }

  private loadUserIntoMap(userId: string): void {
    this.userService
      .getUserById(userId)
      .then((userData) &#x3D;&gt; {
        if (userData) {
          this.userMap[userId] &#x3D; {
            name: userData.name || &#x27;Unbekannt&#x27;,
            avatarUrl: userData.avatarUrl || &#x27;assets/img/avatar.png&#x27;,
          };
        }
      })
      .catch((err) &#x3D;&gt; {});
  }

  /**
   * Builds a message object with correct timestamps, optional date separator,
   * and an intersection cast for showDateSeparator.
   */
  private transformIncomingMessage(
    msg: Message,
    ts: Date,
    showDateSeparator: boolean
  ): Message &amp; { showDateSeparator: boolean } {
    const lr &#x3D; msg.lastResponseTime
      ? this.safeConvertTimestamp(msg.lastResponseTime)
      : ts;
    return {
      ...msg,
      timestamp: ts,
      lastResponseTime: lr,
      formattedDate: this.getFormattedDate(ts),
      showDateSeparator,
      time: formatDate(ts, &#x27;HH:mm&#x27;, &#x27;de&#x27;),
      content: {
        ...msg.content,
        emojis: msg.content?.emojis?.slice() || [],
      },
      replyCount: msg.replyCount ?? 0,
    } as Message &amp; { showDateSeparator: boolean };
  }

  /**
   * Updates live reply counts for each message by subscribing to partialCounts
   * from Firestore. Then applies those counts to local messages.
   */
  private updateLiveReplyCounts(messages: Message[]): void {
    const ids &#x3D; messages
      .map((m) &#x3D;&gt; m.id)
      .filter((id): id is string &#x3D;&gt; id !&#x3D;&#x3D; undefined);
    if (!ids.length) return;

    this.unsubscribeLiveReplyCounts &#x3D; this.messageService.loadReplyCountsLive(
      ids,
      &#x27;private&#x27;,
      (pc) &#x3D;&gt; this.applyPartialCounts(pc)
    );
  }

  /**
   * Applies partial reply counts to local messages. Casts the partialCounts
   * to a known structure so &#x27;data&#x27; is no longer &#x27;unknown&#x27;.
   */
  private applyPartialCounts(
    partialCounts: Record&lt;string, { count: number; lastResponseTime?: any }&gt;
  ): void {
    for (const [msgId, data] of Object.entries(partialCounts)) {
      const idx &#x3D; this.privateMessages.findIndex((m) &#x3D;&gt; m.id &#x3D;&#x3D;&#x3D; msgId);
      if (idx &#x3D;&#x3D;&#x3D; -1) continue;

      this.privateMessages[idx] &#x3D; {
        ...this.privateMessages[idx],
        replyCount: data.count,
        timestamp: this.privateMessages[idx].timestamp,
        time: this.privateMessages[idx].time,
        // If you need lastResponseTime, you can also set it here
      };
    }
  }

  /**
   * Opens a thread (reply view) for the given message. If cached, uses cache; else fetches from Firestore.
   *
   * @param {any} msg - The message containing the thread reference.
   */
  openThreadEvent(msg: any): void {
    this.parentMessage &#x3D; msg;
    const threadId &#x3D; msg.threadId || msg.id;

    if (this.unsubscribeFromThreadMessages) {
      this.unsubscribeFromThreadMessages();
      this.unsubscribeFromThreadMessages &#x3D; null;
    }

    if (this.replyCache.has(threadId)) {
      msg.replies &#x3D; this.replyCache.get(threadId) || [];
      this.openThread.emit(msg);
      return;
    }
    this.loadThread(threadId, msg);
  }

  /**
   * Loads thread messages from Firestore for the given threadId
   * and updates the local privateMessages. Then emits openThread.
   */
  private loadThread(threadId: string, originalMsg: any): void {
    if (this.unsubscribeFromThreadMessages)
      this.unsubscribeFromThreadMessages();

    this.unsubscribeFromThreadMessages &#x3D; this.messageService.listenMessages(
      &#x27;thread&#x27;,
      threadId,
      (messages) &#x3D;&gt; this.handleThreadMessages(messages, originalMsg)
    );
  }

  /**
   * Merges newly received thread messages into privateMessages,
   * updates replyCount/lastResponseTime, then emits openThread.
   */
  private handleThreadMessages(incoming: any[], originMsg: any): void {
    const lastResp &#x3D; incoming.length
      ? this.safeConvertTimestamp(incoming[incoming.length - 1].timestamp)
      : null;

    this.privateMessages &#x3D; this.privateMessages.map((m) &#x3D;&gt; {
      if (m.id !&#x3D;&#x3D; originMsg.id) return m;
      return {
        ...m,
        replies: [...incoming],
        replyCount: incoming.length,
        lastResponseTime: lastResp,
      };
    });
    this.openThread.emit(originMsg);
  }

  /**
   * Starts a listener to track live reply counts for the current privateMessages.
   * Unsubscribes any previous listener, then updates local state when changes occur.
   */
  startLiveReplyCountUpdates(): void {
    if (this.unsubscribeLiveReplyCounts) this.unsubscribeLiveReplyCounts();

    const ids &#x3D; this.privateMessages.map((m) &#x3D;&gt; m.id || &#x27;&#x27;).filter((x) &#x3D;&gt; x);
    if (!ids.length) return;

    this.unsubscribeLiveReplyCounts &#x3D; this.messageService.loadReplyCountsLive(
      ids,
      &#x27;private&#x27;,
      (pc) &#x3D;&gt; {
        this.applyReplyCounts(pc);
      }
    );
  }

  /**
   * Applies partial reply counts from Firestore to each message, updating replyCount
   * and lastResponseTime. If no data entry matches, the message remains unchanged.
   */
  private applyReplyCounts(partialCounts: any): void {
    this.privateMessages &#x3D; this.privateMessages.map((msg) &#x3D;&gt; {
      const data &#x3D; partialCounts[msg.id || &#x27;&#x27;];
      if (!data) return msg;
      return {
        ...msg,
        replyCount: data.count,
        lastResponseTime: data.lastResponseTime
          ? this.safeConvertTimestamp(data.lastResponseTime)
          : null,
      };
    });
  }

  /**
   * Loads the recipient&#x27;s data from the user service if a valid recipientId is set (e.g. name, avatar, status).
   */
  loadRecipientData(): void {
    if (!this.recipientId) {
      return;
    }

    this.userService
      .getUserById(this.recipientId)
      .then((userData) &#x3D;&gt; {
        if (userData) {
          this.recipientName &#x3D; userData.name;
          this.recipientAvatarUrl &#x3D; userData.avatarUrl || &#x27;&#x27;;
          this.recipientStatus &#x3D; userData.isOnline ? &#x27;Aktiv&#x27; : &#x27;Abwesend&#x27;;
        } else {
          // No recipient found
        }
      })
      .catch(() &#x3D;&gt; {
        // Error fetching user
      });
  }

  /**
   * Adds an emoji to a specific message, updates Firestore, and modifies arrays
   * of last-used emojis (sent or received) depending on who authored the message.
   *
   * @param {any} event - The emoji selection event from the picker.
   * @param {any} msg - The message object being updated.
   */
  async addEmojiToMessage(event: any, msg: any): Promise&lt;void&gt; {
    if (!msg.content.emojis) msg.content.emojis &#x3D; [];
    if (!event?.emoji?.native) return;

    const newEmoji &#x3D; event.emoji.native;
    this.processEmojiIncrement(msg, newEmoji);
    this.handleLastUsedEmojis(msg, newEmoji);
    await this.saveEmojiUsageInFirestore(newEmoji);
    await this.updateEmojiInFirestore(msg);

    if (!this.hasScrolledOnChange &amp;&amp; this.isNearBottom()) {
      this.scrollToBottom();
    }
  }

  /**
   * Handles incrementing or inserting the new emoji in the message content.
   */
  private processEmojiIncrement(msg: any, newEmoji: string): void {
    const existing &#x3D; msg.content.emojis.find((e: any) &#x3D;&gt; e.emoji &#x3D;&#x3D;&#x3D; newEmoji);
    if (existing) {
      existing.count &#x3D; 1;
      //existing.count++;
    } else if (msg.content.emojis.length &lt; 20) {
      msg.content.emojis.push({ emoji: newEmoji, count: 1 });
    } else {
      // Limit reached (no logic changed)
    }
  }

  /**
   * Determines if the emoji was sent by the current user or received,
   * then updates the correct last-used array.
   */
  private handleLastUsedEmojis(msg: any, newEmoji: string): void {
    const isSentByMe &#x3D; msg.senderId &#x3D;&#x3D;&#x3D; this.currentUser?.id;
    const emojiType &#x3D; isSentByMe ? &#x27;sent&#x27; : &#x27;received&#x27;;
    if (isSentByMe) {
      this.lastUsedEmojisSent &#x3D; this.updateLastUsedEmojis(
        this.lastUsedEmojisSent,
        newEmoji
      );
    } else {
      this.lastUsedEmojisReceived &#x3D; this.updateLastUsedEmojis(
        this.lastUsedEmojisReceived,
        newEmoji
      );
    }
    if (this.conversationId) {
      this.messageService
        .saveLastUsedEmojis(this.conversationId, [newEmoji], emojiType)
        .catch(() &#x3D;&gt; {});
    }
  }

  /**
   * Updates the message in Firestore with new emoji array,
   * then reflects the changes in this.privateMessages.
   */
  private async updateEmojiInFirestore(msg: any): Promise&lt;void&gt; {
    try {
      await this.messageService.updateMessage(msg.id, {
        &#x27;content.emojis&#x27;: msg.content.emojis,
      });
      this.privateMessages &#x3D; this.privateMessages.map((m) &#x3D;&gt;
        m.id &#x3D;&#x3D;&#x3D; msg.id
          ? { ...m, content: { ...m.content, emojis: msg.content.emojis } }
          : m
      );
    } catch {
      // Could not update message (no logic changed)
    }
  }

  /**
   * Saves the new emoji usage in Firestore only if we have a conversationId,
   * ignoring any error without changing logic.
   */
  private async saveEmojiUsageInFirestore(newEmoji: string): Promise&lt;void&gt; {
    if (!this.conversationId) return;
    // No conversation ID &#x3D;&gt; do nothing
    // (keeping original comment logic)
  }

  /**
   * Maintains an array of last-used emojis by removing duplicates and limiting the array to 2 items.
   *
   * @param {string[]} emojiArray - The array of emojis in memory.
   * @param {string} newEmoji - The new emoji to insert.
   * @returns {string[]} An updated array of emojis.
   */
  private updateLastUsedEmojis(
    emojiArray: string[],
    newEmoji: string
  ): string[] {
    emojiArray &#x3D; emojiArray.filter((e) &#x3D;&gt; e !&#x3D;&#x3D; newEmoji);
    return emojiArray.slice(0, 2);
  }

  /**
   * Listens for real-time emoji usage updates from Firestore, applying them to the
   * local arrays of last used emojis for &#x27;sent&#x27; and &#x27;received&#x27;.
   */
  private listenForEmojiUpdates(): void {
    if (!this.conversationId) return;

    this.unsubscribeEmojiListener &#x3D; this.messageService.listenForEmojiUpdates(
      this.conversationId,
      (sentEmojis, receivedEmojis) &#x3D;&gt; {
        this.lastUsedEmojisSent &#x3D; sentEmojis;
        this.lastUsedEmojisReceived &#x3D; receivedEmojis;
      }
    );
  }

  /**
   * Loads the last used emojis for this conversation in both &#x27;sent&#x27; and &#x27;received&#x27; categories,
   * then starts the real-time emoji usage listener.
   */
  private async loadLastUsedEmojis(): Promise&lt;void&gt; {
    if (!this.currentUser || !this.recipientId) {
      return;
    }

    try {
      const conversationId &#x3D; this.messageService.generateConversationId(
        this.currentUser.id,
        this.recipientId
      );

      const [lastSent, lastReceived] &#x3D; await Promise.all([
        this.messageService.getLastUsedEmojis(conversationId, &#x27;sent&#x27;),
        this.messageService.getLastUsedEmojis(conversationId, &#x27;received&#x27;),
      ]);

      this.lastUsedEmojisSent &#x3D; lastSent || [];
      this.lastUsedEmojisReceived &#x3D; lastReceived || [];

      this.listenForEmojiUpdates();
    } catch (error) {
      // Error loading emojis
    }
  }

  /**
   * Sends a private message (with optional image), updates the UI immediately,
   * replaces temp message with a real Firestore ID, and refreshes emojis/time.
   *
   * @param {HTMLTextAreaElement} textArea - The input area to reset after sending.
   */
  async sendPrivateMessage(textArea: HTMLTextAreaElement): Promise&lt;void&gt; {
    const sid &#x3D; this.userService.getCurrentUserId();
    if (!sid || !this.recipientId) return;

    const cid &#x3D; this.messageService.generateConversationId(
      sid,
      this.recipientId
    );
    let [senderName, senderAvatar] &#x3D; await this.ensureSenderInfo(sid);

    const { timestamp, showDateSeparator, formattedDate } &#x3D;
      this.prepareTimestampInfo();
    const tempMsgId &#x3D; this.createTempMessage(
      cid,
      sid,
      senderName,
      senderAvatar,
      timestamp,
      formattedDate,
      showDateSeparator
    );
    this.scrollToBottom();

    try {
      await this.finalizeMessageInFirestore(cid, sid, tempMsgId);
    } catch {
      /* Error sending message – no logic changed */
    }

    this.postSendCleanup(textArea);
  }

  /**
   * Ensures the sender name/avatar are loaded if missing. Returns [name, avatar].
   */
  private async ensureSenderInfo(senderId: string): Promise&lt;[string, string]&gt; {
    let name &#x3D; this.currentUser?.name || &#x27;Unknown&#x27;;
    let avatar &#x3D; this.currentUser?.avatarUrl || &#x27;assets/img/avatar.png&#x27;;
    if (!name) {
      try {
        const ud &#x3D; await this.userService.getUserById(senderId);
        name &#x3D; ud?.name || &#x27;Unknown&#x27;;
        avatar &#x3D; ud?.avatarUrl || &#x27;assets/default-avatar.png&#x27;;
      } catch {
        /* Error loading user */
      }
    }
    return [name, avatar];
  }

  /**
   * Prepares the current timestamp/date info and determines if a date separator is needed.
   */
  private prepareTimestampInfo(): {
    timestamp: Date;
    showDateSeparator: boolean;
    formattedDate: string;
  } {
    const timestamp &#x3D; new Date();
    const formattedDate &#x3D; this.getFormattedDate(timestamp);
    let showDateSeparator &#x3D; false;

    if (this.privateMessages.length) {
      const lastMsg &#x3D; this.privateMessages[this.privateMessages.length - 1];
      showDateSeparator &#x3D; !this.isSameDay(lastMsg.timestamp, timestamp);
    } else {
      showDateSeparator &#x3D; true;
    }
    return { timestamp, showDateSeparator, formattedDate };
  }

  /**
   * Builds and appends a temporary message into privateMessages, returning the tempMsgId.
   */
  private createTempMessage(
    convId: string,
    senderId: string,
    sName: string,
    sAvatar: string,
    ts: Date,
    fmtDate: string,
    showSep: boolean
  ): string {
    const tempMsgId &#x3D; &#x60;temp-${Math.random().toString(36).substr(2, 9)}&#x60;;
    const tempData &#x3D; {
      id: tempMsgId,
      content: {
        text: this.privateMessage || &#x27;&#x27;,
        image: typeof this.imageUrl &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? this.imageUrl : &#x27;&#x27;,
        emojis: [],
      },
      timestamp: ts,
      formattedDate: fmtDate,
      showDateSeparator: showSep,
      time: formatDate(ts, &#x27;HH:mm&#x27;, &#x27;de&#x27;),
      senderId,
      senderName: sName,
      senderAvatar: sAvatar,
      conversationId: convId,
    };
    this.privateMessages &#x3D; [...this.privateMessages, tempData];
    return tempMsgId;
  }

  /**
   * Sends the final message to Firestore, updates local messages with the real ID
   * and refreshes last-used emojis if found.
   */
  private async finalizeMessageInFirestore(
    cId: string,
    sId: string,
    tempId: string
  ): Promise&lt;void&gt; {
    const fsId &#x3D; await this.messageService.sendMessage({
      type: &#x27;private&#x27;,
      conversationId: cId,
      content: {
        text: this.privateMessage || &#x27;&#x27;,
        image: typeof this.imageUrl &#x3D;&#x3D;&#x3D; &#x27;string&#x27; ? this.imageUrl : &#x27;&#x27;,
        emojis: [],
      },
      senderId: sId,
      recipientId: this.recipientId,
    });

    this.privateMessages &#x3D; this.privateMessages.map((m) &#x3D;&gt;
      m.id &#x3D;&#x3D;&#x3D; tempId ? { ...m, id: fsId } : m
    );
    const saved &#x3D; await this.messageService.getMessage(&#x27;private&#x27;, fsId);
    if (cId &amp;&amp; saved?.content?.emojis?.length) {
      const eArr &#x3D; saved.content.emojis.map((x: { emoji: string }) &#x3D;&gt; x.emoji);
      await this.messageService.saveLastUsedEmojis(cId, eArr, &#x27;sent&#x27;);
    }
    await this.loadLastUsedEmojis();
    this.listenForEmojiUpdates();
  }

  /**
   * Clears the current message &amp; image, resets textarea height, updates date logic.
   */
  private postSendCleanup(txtArea: HTMLTextAreaElement): void {
    this.privateMessage &#x3D; &#x27;&#x27;;
    this.imageUrl &#x3D; null;
    if (txtArea) this.resetTextareaHeight(txtArea);
    this.updateMessageDates();
  }

  /**
   * Saves modifications to an edited message in Firestore, then updates the local message array.
   * Typically called by the template when the user clicks a &quot;save&quot; button.
   *
   * @param {any} msg - The message object with updated content.
   */
  async saveMessage(msg: any): Promise&lt;void&gt; {
    if (msg?.isEditing !&#x3D;&#x3D; undefined) {
      msg.isEditing &#x3D; false; // End editing mode
      const messageId &#x3D; msg.id;

      if (messageId) {
        try {
          await this.messageService.updateMessage(messageId, {
            content: msg.content,
          });

          // Update the local list of messages
          this.privateMessages &#x3D; this.privateMessages.map((m) &#x3D;&gt;
            m.id &#x3D;&#x3D;&#x3D; messageId ? { ...msg, isEditing: false } : m
          );
        } catch (err) {
          // Error updating message
        }
      } else {
        // No message ID
      }
    }
  }

  /**
   * Formats a date as &#x27;Heute&#x27;, &#x27;Gestern&#x27;, or a localized string (e.g. &quot;Samstag, 21. Dezember&quot;).
   * @param {Date | string | null} inputDate - The date or timestamp to format.
   * @returns {string} A user-friendly date string in German.
   */
  getFormattedDate(inputDate: Date | string | null): string {
    if (!inputDate) return &#x27;&#x27;;
    const d &#x3D; inputDate instanceof Date ? inputDate : new Date(inputDate);
    if (isNaN(d.getTime())) return &#x27;Ungültiges Datum&#x27;;

    const now &#x3D; new Date(),
      today &#x3D; new Date(now.getFullYear(), now.getMonth(), now.getDate()),
      yest &#x3D; new Date(today);
    yest.setDate(today.getDate() - 1);

    const cmp &#x3D; new Date(d.getFullYear(), d.getMonth(), d.getDate());
    if (cmp.getTime() &#x3D;&#x3D;&#x3D; today.getTime()) return &#x27;Heute&#x27;;
    if (cmp.getTime() &#x3D;&#x3D;&#x3D; yest.getTime()) return &#x27;Gestern&#x27;;
    return d.toLocaleDateString(&#x27;de-DE&#x27;, {
      weekday: &#x27;long&#x27;,
      day: &#x27;2-digit&#x27;,
      month: &#x27;long&#x27;,
      timeZone: &#x27;Europe/Berlin&#x27;,
    });
  }

  /**
   * Safely converts a given timestamp from Firestore or other types (Date, string, etc.)
   * into a standard JavaScript Date.
   *
   * @param {unknown} timestamp - The timestamp to convert.
   * @returns {Date} A valid Date object, or the current date if conversion fails.
   */
  private safeConvertTimestamp(timestamp: unknown): Date {
    if (!timestamp) return new Date();

    if (typeof (timestamp as any).toDate &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
      return (timestamp as firebase.firestore.Timestamp).toDate();
    }
    if (timestamp instanceof Date) {
      return timestamp;
    }
    if (typeof timestamp &#x3D;&#x3D;&#x3D; &#x27;object&#x27; &amp;&amp; &#x27;seconds&#x27; in (timestamp as object)) {
      const ts &#x3D; timestamp as { seconds: number; nanoseconds: number };
      return new Date(ts.seconds * 1000 + ts.nanoseconds / 1e6);
    }

    const parsedDate &#x3D; new Date(timestamp as string | number);
    return isNaN(parsedDate.getTime()) ? new Date() : parsedDate;
  }

  /**
   * Gets the date object representing &quot;yesterday&quot; for date comparisons if needed.
   */
  private getYesterdayDate(): Date {
    const yesterday &#x3D; new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    return yesterday;
  }

  /**
   * Loads the current user&#x27;s data from Firestore and stores it in &#x60;currentUser&#x60;.
   */
  async loadCurrentUser(): Promise&lt;void&gt; {
    return this.userService
      .getCurrentUserData()
      .then((user) &#x3D;&gt; {
        this.currentUser &#x3D; user;
      })
      .catch(() &#x3D;&gt; {
        // Error getting current user
      });
  }

  /**
   * Called when user selects an image. Reads as data URL, sets imageUrl, optionally adjusts textarea height.
   */
  onImageSelected(event: Event, textArea?: HTMLTextAreaElement): void {
    const input &#x3D; event.target as HTMLInputElement;
    if (input.files &amp;&amp; input.files[0]) {
      const file &#x3D; input.files[0];
      const reader &#x3D; new FileReader();
      reader.onload &#x3D; (e) &#x3D;&gt; {
        this.imageUrl &#x3D; e.target?.result || null;
        if (textArea) {
          this.adjustTextareaHeight(textArea);
        }
        this.isTextareaExpanded &#x3D; true;
      };
      reader.readAsDataURL(file);
    }
  }

  /**
   * Toggles the global emoji picker for sending a new message.
   */
  toggleEmojiPicker(event: MouseEvent) {
    event.stopPropagation();
    this.isEmojiPickerVisible &#x3D; !this.isEmojiPickerVisible;
  }

  /**
   * Adds a globally selected emoji to the current message in the input field.
   */
  addEmoji(event: any): void {
    if (event &amp;&amp; event.emoji &amp;&amp; event.emoji.native) {
      this.privateMessage +&#x3D; event.emoji.native;
    }
  }

  onEmojiPickerClick(e: MouseEvent): void {
    e.stopPropagation(); // Verhindert, dass der Klick als Außenklick gilt.
  }

  /**
   * Opens the image modal if there&#x27;s a selected image to preview.
   */
  openImageModal(): void {
    this.isImageModalOpen &#x3D; true;
  }

  /**
   * Closes the image modal.
   */
  closeImageModal(): void {
    this.isImageModalOpen &#x3D; false;
  }

  /**
   * Closes the image preview/profile card, clearing imageUrl and resetting textarea height.
   */
  closeProfileCard(textArea: HTMLTextAreaElement): void {
    this.imageUrl &#x3D; null;
    this.resetTextareaHeight(textArea);
  }

  /**
   * Expands the textarea bottom padding if an image is present.
   */
  adjustTextareaHeight(textArea: HTMLTextAreaElement): void {
    if (this.imageUrl) {
      textArea.style.paddingBottom &#x3D; &#x27;160px&#x27;;
    }
  }

  /**
   * Resets the textarea&#x27;s bottom padding to a default value.
   */
  resetTextareaHeight(textArea: HTMLTextAreaElement): void {
    textArea.style.paddingBottom &#x3D; &#x27;20px&#x27;;
  }

  /**
   * Handles Enter key in the message input. Sends message if Shift not pressed, otherwise newline.
   */
  handleKeyDown(event: KeyboardEvent, textArea: HTMLTextAreaElement): void {
    if (event.key &#x3D;&#x3D;&#x3D; &#x27;Enter&#x27; &amp;&amp; !event.shiftKey) {
      event.preventDefault();
      this.sendPrivateMessage(textArea);
    }
  }

  /**
   * Loads all users for the mention system or user overlay.
   */
  loadAllUsers(): void {
    this.userService
      .getAllUsers()
      .then((users) &#x3D;&gt; {
        this.allUsers &#x3D; users.map((u) &#x3D;&gt; ({
          id: u.id,
          name: u.name,
          avatarUrl: u.avatarUrl || &#x27;assets/img/avatar.png&#x27;,
          isOnline: u.isOnline ?? false,
        }));
      })
      .catch((err) &#x3D;&gt; console.error(&#x27;Fehler beim Laden der Nutzer:&#x27;, err));
  }

  /**
   * Toggles the dropdown in a 4-step cycle:
   * 1) hidden -&gt; user
   * 2) user -&gt; channel
   * 3) channel -&gt; user
   * 4) user -&gt; hidden
   * @param {MouseEvent} event - The button click event.
   */
  toggleDropdown(event: MouseEvent): void {
    event.stopPropagation();
    if (this.cycleStep &#x3D;&#x3D;&#x3D; 1) {
      this.dropdownState &#x3D; &#x27;user&#x27;;
      this.cycleStep &#x3D; 2;
    } else if (this.cycleStep &#x3D;&#x3D;&#x3D; 2) {
      this.dropdownState &#x3D; &#x27;channel&#x27;;
      this.cycleStep &#x3D; 3;
    } else if (this.cycleStep &#x3D;&#x3D;&#x3D; 3) {
      this.dropdownState &#x3D; &#x27;user&#x27;;
      this.cycleStep &#x3D; 4;
    } else {
      this.dropdownState &#x3D; &#x27;hidden&#x27;;
      this.cycleStep &#x3D; 1;
    }
  }
  /**
   * Closes the dropdown, resetting its state to hidden.
   */
  closeDropdown(): void {
    this.dropdownState &#x3D; &#x27;hidden&#x27;;
    this.cycleStep &#x3D; 1;
  }

  /** Resets the dropdown to its default hidden state. */
  private resetDropdown(): void {
    this.dropdownState &#x3D; &#x27;hidden&#x27;;
    this.cycleStep &#x3D; 1;
    this.lastOpenedChar &#x3D; &#x27;&#x27;;
  }

  /**
   * Evaluates user/channel mention state or hides it based on input events.
   * @param {Event} event - The input event from the textarea.
   */
  onTextareaInput(event: Event): void {
    const i &#x3D; event as InputEvent,
      t &#x3D; (event.target as HTMLTextAreaElement).value;
    if (
      [&#x27;deleteContentBackward&#x27;, &#x27;deleteContentForward&#x27;].includes(i.inputType)
    ) {
      if (!t.includes(&#x27;@&#x27;) &amp;&amp; this.dropdownState &#x3D;&#x3D;&#x3D; &#x27;user&#x27;)
        this.resetDropdown();
      this.lastOpenedChar &#x3D; &#x27;&#x27;;
      if (!t.includes(&#x27;#&#x27;) &amp;&amp; this.dropdownState &#x3D;&#x3D;&#x3D; &#x27;channel&#x27;)
        this.resetDropdown();
      this.lastOpenedChar &#x3D; &#x27;&#x27;;
      return;
    }
    if (t.endsWith(&#x27;@&#x27;) &amp;&amp; this.lastOpenedChar !&#x3D;&#x3D; &#x27;@&#x27;) {
      this.dropdownState &#x3D; &#x27;user&#x27;;
      this.lastOpenedChar &#x3D; &#x27;@&#x27;;
    } else if (t.endsWith(&#x27;#&#x27;) &amp;&amp; this.lastOpenedChar !&#x3D;&#x3D; &#x27;#&#x27;) {
      this.dropdownState &#x3D; &#x27;channel&#x27;;
      this.lastOpenedChar &#x3D; &#x27;#&#x27;;
    } else this.lastOpenedChar &#x3D; &#x27;&#x27;;
  }

  /**
   * Inserts a channel mention into the message text, removing any trailing &#x27;#&#x27;,
   * then closes the dropdown.
   * @param {any} channel - The channel object to mention.
   */
  selectChannel(channel: any): void {
    if (this.privateMessage.endsWith(&#x27;#&#x27;)) {
      this.privateMessage &#x3D; this.privateMessage.slice(0, -1);
    }
    this.privateMessage +&#x3D; &#x60;#${channel.name} &#x60;;
    this.closeDropdown();
  }

  /**
   * Adds an &quot;@username&quot; mention to the &#x60;privateMessage&#x60; input and closes the dropdown.
   */
  addUserSymbol(member: any) {
    if (this.privateMessage.endsWith(&#x27;@&#x27;)) {
      this.privateMessage &#x3D; this.privateMessage.slice(0, -1);
    }
    this.privateMessage +&#x3D; &#x60; @${member.name} &#x60;;
    this.closeDropdown();
  }

  /**
   * Highlights a message by ID, scrolling it into view and applying a CSS highlight class briefly.
   */
  highlightMessage(messageId: string, retries &#x3D; 5): void {
    setTimeout(() &#x3D;&gt; {
      const messageElement &#x3D; document.getElementById(&#x60;message-${messageId}&#x60;);
      if (messageElement) {
        messageElement.scrollIntoView({ behavior: &#x27;smooth&#x27;, block: &#x27;center&#x27; });
        messageElement.classList.add(&#x27;highlight&#x27;);
        setTimeout(() &#x3D;&gt; messageElement.classList.remove(&#x27;highlight&#x27;), 2000);
      } else if (retries &gt; 0) {
        this.highlightMessage(messageId, retries - 1);
      }
    }, 500);
  }

  /**
   * Toggles an inline emoji picker for a specific message. Ensures only one is visible at a time.
   */
  toggleEmojiPickerForMessage(msg: any): void {
    const isCurrentlyVisible &#x3D; msg.isEmojiPickerVisible;
    this.privateMessages.forEach((m) &#x3D;&gt; (m.isEmojiPickerVisible &#x3D; false));
    msg.isEmojiPickerVisible &#x3D; !isCurrentlyVisible;
  }

  /**
   * Generates a unique conversation ID by sorting two user IDs alphabetically and joining them.
   */
  generateConversationId(userId1: string, userId2: string): string {
    return [userId1, userId2].sort().join(&#x27;_&#x27;);
  }

  /**
   * Toggles edit options for a given message, identified by its ID.
   */
  toggleEditOptions(msgId: string): void {
    if (this.currentMessageId &#x3D;&#x3D;&#x3D; msgId &amp;&amp; this.showEditOptions) {
      this.showEditOptions &#x3D; false;
      this.currentMessageId &#x3D; null;
    } else {
      this.showEditOptions &#x3D; true;
      this.currentMessageId &#x3D; msgId;
    }
  }

  /**
   * Marks a message as &quot;isEditing &#x3D; true,&quot; storing its original content.
   */
  startEditing(msg: any): void {
    msg.isEditing &#x3D; true;
    this.originalMessage &#x3D; JSON.parse(JSON.stringify(msg));
    this.showEditOptions &#x3D; false;
  }

  /**
   * Toggles a message to editing mode, also storing the original for potential revert on cancel.
   */
  toggleEditMessage(msg: any): void {
    msg.isEditing &#x3D; true;
    this.originalMessage &#x3D; { ...msg };
  }

  /**
   * Cancels editing a message, reverting any text changes to the original content.
   */
  cancelEditing(msg: any): void {
    if (this.originalMessage) {
      msg.content.text &#x3D; this.originalMessage.content.text;
      this.originalMessage &#x3D; null;
    }
    msg.isEditing &#x3D; false;
    this.showEditOptions &#x3D; false;
  }

  /**
   * Returns only the channels in which the current user is a member.
   *
   * 1. Checks if the current user (with a valid &#x60;uid&#x60;) and the &#x60;allChannels&#x60; list exist.
   * 2. Filters &#x60;allChannels&#x60; by verifying if each channel&#x27;s &#x60;members&#x60; array
   *    contains an object whose &#x60;uid&#x60; matches the &#x60;currentUser.uid&#x60;.
   * 3. If either the user or channel list is unavailable, returns an empty array.
   *
   * @returns {any[]} An array of channels where the current user is a member.
   */
  get filteredChannels(): any[] {
    if (!this.currentUser?.uid || !this.allChannels) {
      return [];
    }

    return this.allChannels.filter((ch) &#x3D;&gt;
      ch.members?.some((m: any) &#x3D;&gt; m.uid &#x3D;&#x3D;&#x3D; this.currentUser.uid)
    );
  }

  /**
   * Displays the tooltip for a hovered emoji at a position slightly above its horizontal center.
   *
   * 1. Sets the tooltip visibility, the hovered emoji, and the sender name.
   * 2. Retrieves the bounding rectangle of the hovered element to calculate its center.
   * 3. Positions the tooltip horizontally at the midpoint, and slightly above the element (using a small offset).
   *
   * @param {MouseEvent} event - The mouse event triggered by hovering over the emoji.
   * @param {string} emoji - The emoji character being hovered.
   * @param {string} senderName - The name of the user who used the emoji.
   * @returns {void}
   */
  showTooltip(event: MouseEvent, emoji: string, senderName: string): void {
    this.tooltipVisible &#x3D; true;
    this.tooltipEmoji &#x3D; emoji;
    this.tooltipSenderName &#x3D; senderName;

    const targetElem &#x3D; event.target as HTMLElement;
    const rect &#x3D; targetElem.getBoundingClientRect();

    const offset &#x3D; 5;
    this.tooltipPosition &#x3D; {
      x: rect.left + rect.width / 2 + window.scrollX, // horizontal midpoint
      y: rect.top + window.scrollY - offset, // slightly above the element
    };
  }

  /**
   * Hides the emoji tooltip.
   */
  hideTooltip(): void {
    this.tooltipVisible &#x3D; false;
  }

  /**
   * Closes any expanded popup that displays all emojis in a given message.
   */
  closePopup(msg: any) {
    if (msg.showAllEmojisList) {
      msg.showAllEmojisList &#x3D; false;
      msg.expanded &#x3D; false;
    }
  }

  /**
   * Toggles a popup listing all emojis in a particular message.
   */
  toggleEmojiPopup(msg: any) {
    if (msg.showAllEmojisList &#x3D;&#x3D;&#x3D; undefined) {
      msg.showAllEmojisList &#x3D; false;
    }
    msg.showAllEmojisList &#x3D; !msg.showAllEmojisList;

    if (!msg.showAllEmojisList) {
      msg.expanded &#x3D; false;
    } else if (msg.expanded &#x3D;&#x3D;&#x3D; undefined) {
      msg.expanded &#x3D; false;
    }
  }

  /**
   * (Log entfernt) Logs &quot;plus&quot; icon clicks in the emoji popup, if your UI uses it to add a new emoji or open a picker.
   */
  onEmojiPlusInPopup(msg: any) {
    // console.log(&#x27;Plus clicked in emoji popup, msg&#x3D;&#x27;, msg);  // REMOVED
  }

  /**
   * Opens a large view of the given image if it is a string (URL or dataURL).
   */
  openLargeImage(imageData: string | ArrayBuffer) {
    if (typeof imageData !&#x3D;&#x3D; &#x27;string&#x27;) {
      return;
    }
    this.largeImageUrl &#x3D; imageData;
    this.showLargeImage &#x3D; true;
  }

  /**
   * Closes the currently displayed large image.
   */
  closeLargeImage() {
    this.showLargeImage &#x3D; false;
    this.largeImageUrl &#x3D; null;
  }

  /**
   * Checks if two Date objects are on the same day, ignoring times.
   */
  private isSameDay(date1: Date | null, date2: Date | null): boolean {
    if (!date1 || !date2) return false;
    return (
      date1.getDate() &#x3D;&#x3D;&#x3D; date2.getDate() &amp;&amp;
      date1.getMonth() &#x3D;&#x3D;&#x3D; date2.getMonth() &amp;&amp;
      date1.getFullYear() &#x3D;&#x3D;&#x3D; date2.getFullYear()
    );
  }














   /**
 * Finds the index of a given emoji within a message&#x27;s emoji list.
 * @param {any} message - The message object containing a content.emojis array.
 * @param {string} emojiToRemove - The emoji to look for.
 * @returns {number} The index of the emoji or -1 if not found.
 */
private findEmojiIndex(message: any, emojiToRemove: string): number {
  if (!message?.content?.emojis) return -1;
  return message.content.emojis.findIndex(
    (emojiObj: any) &#x3D;&gt; emojiObj.emoji &#x3D;&#x3D;&#x3D; emojiToRemove
  );
}

/**
 * Removes the emoji at the specified index from the message&#x27;s content.
 * @param {any} message - The message object with a content.emojis array.
 * @param {number} index - The position of the emoji to remove.
 */
private removeEmojiAtIndex(message: any, index: number): void {
  message.content.emojis.splice(index, 1);
}

/**
 * Updates the message document in Firestore, hiding the tooltip in every scenario.
 * @param {any} message - The message object containing the ID and updated content.
 */
private updateMessageInFirestore(message: any): void {
  if (!message.id) {
    this.hideTooltip();
    return;
  }
  this.messageService
    .updateMessage(message.id, { content: message.content })
    .then(() &#x3D;&gt; this.hideTooltip())
    // Bei Fehlern ebenfalls Tooltip schließen:
    .catch(() &#x3D;&gt; this.hideTooltip());
}

/**
 * Removes a specific emoji from the message content and triggers Firestore update.
 * @param {any} message - The message object (requires content.emojis and an ID).
 * @param {string} emojiToRemove - The emoji to remove from the message.
 */
public removeEmojiFromMessage(message: any, emojiToRemove: string): void {
  const index &#x3D; this.findEmojiIndex(message, emojiToRemove);
  if (index &#x3D;&#x3D;&#x3D; -1) return;
  this.removeEmojiAtIndex(message, index);
  this.updateMessageInFirestore(message);
}


}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'MessageContent-2.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
